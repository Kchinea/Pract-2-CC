# Pr√°ctica 2 - Simulador de M√°quinas de Turing Multicinta

**Asignatura:** Complejidad Computacional  
**Autor:** Kyliam Gabriel Chinea Salcedo  
**Curso:** 2024-2025

---

## üìã √çndice

1. [Introducci√≥n](#-introducci√≥n)
2. [Formato de Inputs](#-formato-de-inputs)
   - [Formato del fichero de definici√≥n de MT](#formato-del-fichero-de-definici√≥n-de-mt)
   - [Formato del fichero de cadenas](#formato-del-fichero-de-cadenas)
3. [Ejercicios de M√°quinas de Turing](#-ejercicios-de-m√°quinas-de-turing)
   - [Ejercicio 1: Lenguaje a^n b^m (m > n, n ‚â• 1)](#ejercicio-1-lenguaje-an-bm-m--n-n--1)
   - [Ejercicio 2: [Por completar]](#ejercicio-2-por-completar)
4. [Arquitectura del C√≥digo](#-arquitectura-del-c√≥digo)
   - [Diagrama de Clases](#diagrama-de-clases)
   - [Descripci√≥n Detallada de Clases](#descripci√≥n-detallada-de-clases)
5. [Compilaci√≥n y Ejecuci√≥n](#-compilaci√≥n-y-ejecuci√≥n)
6. [Ejemplos de Uso](#-ejemplos-de-uso)

---

## üéØ Introducci√≥n

Este proyecto implementa un **simulador de M√°quinas de Turing multicinta** en C++11. El simulador es capaz de:

- ‚úÖ Parsear definiciones de MT desde ficheros de texto
- ‚úÖ Ejecutar simulaciones sobre m√∫ltiples cadenas de entrada
- ‚úÖ Soportar transiciones multicinta (m√∫ltiples cabezas lectoras/escritoras)
- ‚úÖ Proporcionar un modo de traza detallado para debugging
- ‚úÖ Generar resultados en formato estructurado

El proyecto sigue principios de **dise√±o orientado a objetos** con separaci√≥n de responsabilidades, encapsulaci√≥n y uso de referencias en lugar de punteros para mayor seguridad.

---

## üìÑ Formato de Inputs

### Formato del fichero de definici√≥n de MT

El fichero de definici√≥n de una M√°quina de Turing consta de **7 secciones**, una por l√≠nea:

```
<estados>
<alfabeto_entrada>
<alfabeto_cinta>
<estado_inicial>
<simbolo_blanco>
<estados_aceptacion>
<transiciones>
```

#### Descripci√≥n de cada secci√≥n:

1. **Estados**: Lista de estados separados por espacios
   ```
   q0 q1 q2 qaccept qreject
   ```

2. **Alfabeto de entrada**: S√≠mbolos del alfabeto de entrada (Œ£)
   ```
   a b
   ```

3. **Alfabeto de cinta**: S√≠mbolos del alfabeto de cinta (Œì), debe incluir el blanco
   ```
   a b X Y .
   ```

4. **Estado inicial**: Estado donde comienza la ejecuci√≥n
   ```
   q0
   ```

5. **S√≠mbolo blanco**: S√≠mbolo que representa celdas vac√≠as (normalmente `.`)
   ```
   .
   ```

6. **Estados de aceptaci√≥n**: Estados que aceptan la cadena (separados por espacios)
   ```
   qaccept
   ```

7. **Transiciones**: Una transici√≥n por l√≠nea con formato:
   ```
   <estado_origen> <s√≠mbolo_le√≠do> <estado_destino> <s√≠mbolo_escrito_cinta0> <movimiento_cinta0> [<s√≠mbolo_escrito_cinta1> <movimiento_cinta1> ...]
   ```

   **Movimientos:**
   - `L` - Izquierda (Left)
   - `R` - Derecha (Right)
   - `S` - Sin movimiento (Stay)

#### Ejemplo completo:

```
q0 q1 qaccept
a b
a b .
q0
.
qaccept
q0 a q1 . R
q1 b qaccept . R
```

### Formato del fichero de cadenas

Fichero de texto plano donde **cada l√≠nea contiene una cadena de entrada** a procesar:

```
aa
ab
ba
aabb
```

**Nota:** Las l√≠neas vac√≠as son ignoradas autom√°ticamente.

---

## üßÆ Ejercicios de M√°quinas de Turing

### Ejercicio 1: Lenguaje a^n b^m (m > n, n ‚â• 1)

**Objetivo:** Dise√±ar una MT que reconozca el lenguaje L = {a^n b^m | m > n, n ‚â• 1}

**Descripci√≥n:**
- La cadena debe tener **al menos una 'a'** seguida de **al menos dos 'b'**
- Debe haber **estrictamente m√°s 'b's que 'a's**
- Ejemplos v√°lidos: `abb`, `abbb`, `aabbb`, `aaabbbb`
- Ejemplos inv√°lidos: `ab`, `aabb`, `aaabbb`, `a`, `b`

**Estrategia de la MT:**

1. **Fase de marcado:** Marca cada 'a' con 'X' y cada 'b' con 'Y'
2. **Fase de verificaci√≥n:** Cuenta que haya al menos una 'b' sin marcar al final
3. **Aceptaci√≥n:** Si quedan 'b's sin marcar y todas las 'a's est√°n marcadas

**Diagrama de Estados:**

```
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ                                     ‚îÇ
                    ‚ñº                                     ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê   a/X,R  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê   Y/Y,R    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê   b/Y,L     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ ‚îê
‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ q0 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ q1 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ q1 ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ q2  ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îò            ‚îî‚îÄ‚î¨‚îÄ‚îÄ‚îò             ‚îî‚îÄ‚îÄ ‚î¨‚îÄ‚îò
                       ‚îÇ                 ‚îÇ                   ‚îÇ
                       ‚îÇ b/Y,R           ‚îÇ ./.,R             ‚îÇ X/X,L
                       ‚îÇ                 ‚îÇ                   ‚îÇ
                       ‚îÇ                 ‚îÇ                   ‚îÇ
                       ‚îÇ              ‚îå‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îê                ‚îÇ
                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇqaccept               ‚îÇ
                                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ
                                         ‚ñ≤                   ‚îÇ
                                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                              a/X,R
    
    Estados:
    ‚Ä¢ q0: Estado inicial, busca primera 'a'
    ‚Ä¢ q1: Avanza buscando una 'b' para emparejar
    ‚Ä¢ q2: Retrocede al inicio para siguiente ciclo
    ‚Ä¢ qaccept: Acepta si hay 'b's extra
    
    S√≠mbolos:
    ‚Ä¢ a, b: S√≠mbolos originales
    ‚Ä¢ X: 'a' marcada (procesada)
    ‚Ä¢ Y: 'b' marcada (procesada)
    ‚Ä¢ .: Blanco
```

**Archivo:** `Inputs/MT/AnBn_Plus_MT.txt`

**Tabla completa de transiciones:**

| Estado | S√≠mbolo le√≠do | Estado destino | S√≠mbolo escrito | Movimiento |
|--------|---------------|----------------|-----------------|------------|
| q0     | a             | q1             | X               | R          |
| q0     | X             | q0             | X               | R          |
| q0     | Y             | q3             | Y               | R          |
| q1     | a             | q1             | a               | R          |
| q1     | Y             | q1             | Y               | R          |
| q1     | b             | q2             | Y               | L          |
| q2     | a             | q2             | a               | L          |
| q2     | Y             | q2             | Y               | L          |
| q2     | X             | q2             | X               | L          |
| q2     | .             | q0             | .               | R          |
| q3     | Y             | q3             | Y               | R          |
| q3     | b             | qaccept        | b               | S          |

**Explicaci√≥n detallada:**

1. **Estado q0 (B√∫squeda de 'a' no marcada):**
   - `q0 --a/X,R--> q1`: Encuentra 'a', la marca como 'X' y busca su 'b'
   - `q0 --X/X,R--> q0`: Salta 'X's (a's ya procesadas)
   - `q0 --Y/Y,R--> q3`: Solo quedan 'Y's, verifica que haya 'b's sin marcar

2. **Estado q1 (B√∫squeda de 'b' para emparejar):**
   - `q1 --a/a,R--> q1`: Salta 'a's no procesadas
   - `q1 --Y/Y,R--> q1`: Salta 'Y's (b's ya emparejadas)
   - `q1 --b/Y,L--> q2`: Encuentra 'b', la marca como 'Y' y retrocede

3. **Estado q2 (Retroceso al inicio):**
   - `q2 --a/a,L--> q2`: Retrocede sobre 'a's
   - `q2 --Y/Y,L--> q2`: Retrocede sobre 'Y's
   - `q2 --X/X,L--> q2`: Retrocede sobre 'X's
   - `q2 --./.,R--> q0`: Alcanza blanco inicial, reinicia ciclo

4. **Estado q3 (Verificaci√≥n de 'b's extras):**
   - `q3 --Y/Y,R--> q3`: Avanza sobre 'Y's buscando 'b' sin marcar
   - `q3 --b/b,S--> qaccept`: ¬°Encuentra 'b' extra! ‚Üí ACEPTA (m > n)

**Transiciones (formato compacto):**
```
# Estado q0: Buscar 'a' no marcada
q0 a q1 X R    # Marca 'a' como 'X'
q0 X q0 X R    # Salta 'X's procesadas
q0 Y q3 Y R    # Todas las 'a's procesadas, verifica extras

# Estado q1: Buscar 'b' para emparejar
q1 a q1 a R    # Avanza sobre 'a's
q1 Y q1 Y R    # Avanza sobre 'Y's
q1 b q2 Y L    # Marca 'b', retrocede

# Estado q2: Retroceder al inicio
q2 a q2 a L    # Retrocede sobre 'a'
q2 Y q2 Y L    # Retrocede sobre 'Y'
q2 X q2 X L    # Retrocede sobre 'X'
q2 . q0 . R    # Vuelve al inicio

# Estado q3: Verificar 'b's extras
q3 Y q3 Y R    # Salta 'Y's
q3 b qaccept b S  # ¬°'b' extra! ‚Üí ACEPTA
```

**Cadenas de prueba:**
```bash
./pract-02 Inputs/MT/AnBn_Plus_MT.txt Inputs/Strigs/strings_anbn_plus.txt
```

**Resultados esperados:**
- ‚úÖ `abb` ‚Üí ACEPTADA
- ‚úÖ `abbb` ‚Üí ACEPTADA
- ‚úÖ `aabbb` ‚Üí ACEPTADA
- ‚ùå `ab` ‚Üí RECHAZADA
- ‚ùå `aabb` ‚Üí RECHAZADA
- ‚ùå `aaabbb` ‚Üí RECHAZADA

---

### Ejercicio 2: Contador de 'a's y 'b's en Formato Unario (3 cintas)

**Objetivo:** Contar el n√∫mero de 'a's y 'b's en la cadena de entrada y escribir el resultado en formato unario.

**Descripci√≥n:**
Dada una cadena de entrada w ‚àà {a, b}*, la m√°quina debe transformarla en:
```
.1^(n_a+1).1^(n_b+1).
```
donde:
- n_a = n√∫mero de 'a's en la cadena
- n_b = n√∫mero de 'b's en la cadena
- Cada grupo de unos representa el conteo + 1 (m√≠nimo)

**Ejemplos:**
- `a` ‚Üí `.11.1.` (1 'a' ‚Üí 11, 0 'b's ‚Üí 1)
- `aa` ‚Üí `.111.1.` (2 'a's ‚Üí 111, 0 'b's ‚Üí 1)
- `b` ‚Üí `.1.11.` (0 'a's ‚Üí 1, 1 'b' ‚Üí 11)
- `abb` ‚Üí `.11.111.` (1 'a' ‚Üí 11, 2 'b's ‚Üí 111)

**Estrategia de la MT (3 cintas):**

**Cintas:**
- **Cinta 0**: Entrada/Salida - se transforma progresivamente
- **Cinta 1**: Cinta auxiliar para contar (1's temporales)
- **Cinta 2**: Cinta auxiliar adicional (sin uso activo)

**Fases:**

1. **Fase 1: Contar 'a's**
   - Recorrer cinta 0 buscando 'a's
   - Por cada 'a' encontrada: borrarla de cinta 0, escribir '1' en cinta 1
   - Las 'b's se preservan para la siguiente fase

2. **Fase 2: Escribir resultado de 'a's en cinta 0**
   - Agregar '1' inicial (m√≠nimo)
   - Leer '1's de cinta 1 y escribirlos en cinta 0
   - Escribir punto separador '.'

3. **Fase 3: Contar 'b's**
   - Recorrer cinta 0 buscando 'b's
   - Por cada 'b' encontrada: borrarla, escribir '1' en cinta 1

4. **Fase 4: Escribir resultado de 'b's**
   - Agregar '1' inicial (m√≠nimo)
   - Copiar '1's de cinta 1 a cinta 0
   - Finalizar en estado de aceptaci√≥n

**Diagrama de Estados:**
```
                    a/.,R
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  a/.,R       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ q0 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ   q1   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ q1 ‚îÇ (Contar a's)
    ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò              ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îò
       ‚îÇ              ‚îÇ b                   ‚îÇ .
       ‚îÇ b            ‚ñº                     ‚ñº
       ‚îÇ          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ q2 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ q3 ‚îÇ (Escribir resultado a's)
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò      .          ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îò
                                            ‚îÇ
                                            ‚ñº
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ q5 ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ q4 ‚îÇ (Agregar 1 extra a's)
                  ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îò                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ b/.,R
                     ‚ñº
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ q6 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ q7 ‚îÇ (Escribir resultado b's)
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò      .          ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îò
                                            ‚îÇ
                                            ‚ñº
                                        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                        ‚îÇqaccept ‚îÇ
                                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Archivo:** `Inputs/MT/CountAB_2Tapes_MT.txt` *(nota: nombre de archivo mantiene "2Tapes" pero usa 3)*

**Formato de transiciones (3 cintas):**
```
<estado> <lec0> <sig_estado> <esc0> <mov0> <lec1> <esc1> <mov1> <lec2> <esc2> <mov2>
```

**Transiciones principales:**
```
# Contar a's (borrar de cinta 0, escribir en cinta 1)
q0 a q1 . R . 1 R . . S    # Lee 'a', borra, escribe '1' en cinta 1
q1 a q1 . R . 1 R . . S    # Contin√∫a contando 'a's

# Encontrar b o fin de a's
q1 b q2 b S . . S . . S    # Encontr√≥ 'b', preparar fase de escritura
q1 . q8 1 L . . S . . S    # No hay b's, ir a escribir solo a's

# Escribir resultado de a's
q3 . q3 1 L . . S 1 . L    # Escribe '1's en cinta 0
q4 . q4 1 L 1 . L . . S    # Agrega '1' extra para a's

# Contar b's
q5 b q5 . R . . S . 1 R    # Borra 'b', escribe '1' en cinta 2
q6 . q6 1 L . . S 1 . L    # Escribe '1's para b's

# Agregar 1 extra para b's
q7 . q7 1 L 1 . L . . S    # Agrega '1' extra
q7 . qaccept . L . . L . . L  # Acepta
```

**Cadenas de prueba:**
```bash
./pract-02 Inputs/MT/CountAB_2Tapes_MT.txt Inputs/Strigs/strings_ab.txt
```

**Resultados esperados:**
- ‚úÖ `a` ‚Üí `.11.1.` (1 'a', 0 'b's)
- ‚úÖ `aa` ‚Üí `.111.1.` (2 'a's, 0 'b's)
- ‚úÖ `abb` ‚Üí `.11.111.` (1 'a', 2 'b's)
- ‚úÖ `b` ‚Üí `.1.11.` (0 'a's, 1 'b')

---

### Ejemplos Adicionales de M√°quinas de Turing

#### Ejemplo 1: N√∫mero Par de 'a's (1 cinta)

**Lenguaje:** L = {w ‚àà {a,b}* | w contiene un n√∫mero par de 'a's}

**Diagrama de Estados:**

```
              a/a,R
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ               ‚îÇ
        ‚îÇ               ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê   b/b,R   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ./.,S   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ q0 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ q0 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇqaccept ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚ñ≤                  ‚îÇ
      ‚îÇ                  ‚îÇ a/a,R
      ‚îÇ                  ‚ñº
      ‚îÇ   b/b,R       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ q1 ‚îÇ
                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    
    Estados:
    ‚Ä¢ q0: N√∫mero par de 'a's vistas (estado aceptador)
    ‚Ä¢ q1: N√∫mero impar de 'a's vistas
    ‚Ä¢ qaccept: Estado final de aceptaci√≥n
    
    Transiciones:
    ‚Ä¢ Desde q0: 'a' ‚Üí q1 (par ‚Üí impar)
    ‚Ä¢ Desde q1: 'a' ‚Üí q0 (impar ‚Üí par)
    ‚Ä¢ Las 'b's no cambian el estado (autobucle)
```

**Archivo:** `Inputs/MT/EvenAs_1Tape_MT.txt`

**Tabla completa de transiciones:**

| Estado | S√≠mbolo le√≠do | Estado destino | S√≠mbolo escrito | Movimiento |
|--------|---------------|----------------|-----------------|------------|
| q0     | a             | q1             | a               | R          |
| q0     | b             | q0             | b               | R          |
| q0     | .             | qaccept        | .               | S          |
| q1     | a             | q0             | a               | R          |
| q1     | b             | q1             | b               | R          |
| q1     | .             | q1             | .               | S          |

**Explicaci√≥n:**
- **q0 (par)**: Al leer 'a' va a q1 (impar), al leer 'b' permanece en q0, al leer '.' acepta
- **q1 (impar)**: Al leer 'a' va a q0 (par), al leer 'b' permanece en q1, al leer '.' rechaza (autobucle infinito)

**Transiciones:**
```
q0 a q1 a R      # Par ‚Üí Impar
q0 b q0 b R      # Salta 'b's sin cambiar paridad
q0 . qaccept . S # Blanco en estado par ‚Üí ACEPTA
q1 a q0 a R      # Impar ‚Üí Par
q1 b q1 b R      # Salta 'b's sin cambiar paridad
q1 . q1 . S      # Blanco en estado impar ‚Üí Bucle infinito (RECHAZA)
```

**Ejemplos:**
- ‚úÖ `aa`, `aaaa`, `bb`, `aabb`, `abab` ‚Üí ACEPTADAS
- ‚ùå `a`, `aaa`, `ababab` ‚Üí RECHAZADAS

---

#### Ejemplo 2: Lenguaje a*b* (1 cinta)

**Lenguaje:** L = {a^n b^m | n,m ‚â• 0}

**Diagrama de Estados:**

```
              a/a,R
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ               ‚îÇ
        ‚îÇ               ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê   b/b,R    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ./.,S    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ q0 ‚îÇ            ‚îÇ q0 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ q1 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇqaccept ‚îÇ
    ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                                   ‚îÇ
       ‚îÇ ./.,S                             ‚îÇ b/b,R
       ‚îÇ                                   ‚îÇ
       ‚îÇ                                   ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    
    Estados:
    ‚Ä¢ q0: Leyendo 'a's (acepta Œµ tambi√©n)
    ‚Ä¢ q1: Leyendo 'b's (no puede volver a 'a's)
    ‚Ä¢ qaccept: Aceptaci√≥n
    
    Funcionamiento:
    ‚Ä¢ En q0: lee todas las 'a's
    ‚Ä¢ Al encontrar 'b': transiciona a q1
    ‚Ä¢ En q1: solo acepta 'b's y blanco
    ‚Ä¢ Si encuentra 'a' despu√©s de 'b': RECHAZA (no hay transici√≥n)
```

**Archivo:** `Inputs/MT/AStarBStar_1Tape_MT.txt`

**Tabla completa de transiciones:**

| Estado | S√≠mbolo le√≠do | Estado destino | S√≠mbolo escrito | Movimiento |
|--------|---------------|----------------|-----------------|------------|
| q0     | a             | q0             | a               | R          |
| q0     | b             | q1             | b               | R          |
| q0     | .             | qaccept        | .               | S          |
| q1     | b             | q1             | b               | R          |
| q1     | .             | qaccept        | .               | S          |

**Explicaci√≥n:**
- **q0**: Acepta 'a's y permanece en q0, al ver 'b' pasa a q1, al ver '.' acepta (cadena vac√≠a o solo a's)
- **q1**: Solo acepta 'b's y blanco. No hay transici√≥n para 'a', por lo que rechaza si aparece 'a' despu√©s de 'b'

**Transiciones:**
```
q0 a q0 a R      # Lee 'a's consecutivas
q0 b q1 b R      # Primera 'b' ‚Üí cambia a modo "solo b's"
q0 . qaccept . S # Acepta cadena vac√≠a o solo a's
q1 b q1 b R      # Lee 'b's consecutivas
q1 . qaccept . S # Acepta al terminar con b's
# NO HAY: q1 a ... ‚Üí Por tanto, rechaza si hay 'a' despu√©s de 'b'
```

**Ejemplos:**
- ‚úÖ `a`, `b`, `aa`, `bb`, `ab`, `aabb`, `aaabbb` ‚Üí ACEPTADAS
- ‚ùå `ba`, `aba`, `abba` ‚Üí RECHAZADAS

---

#### Ejemplo 3: Reversi√≥n Binaria (2 cintas)

**Lenguaje:** Copia la cadena binaria y la invierte en la cinta 2

**Diagrama de Estados (simplificado):**

```
                    0/0,R; 0,R
                    1/1,R; 1,R
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                          ‚îÇ
        ‚îÇ                          ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ./.,L; .,L   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ q0 ‚îÇ                      ‚îÇ q0 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ q1 ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îò
                                                         ‚îÇ
                                                         ‚îÇ 0/.,L; 0,L
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ 1/.,L; 1,L
                    ‚îÇ                                    ‚îÇ
                    ‚îÇ                                    ‚ñº
                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê                              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ./.,S; .,S   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                 ‚îÇqaccept‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ q1 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇqaccept ‚îÇ
                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò                              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    
    Funcionamiento (2 cintas):
    ‚Ä¢ Cinta 0: Lee la entrada
    ‚Ä¢ Cinta 1: Escribe la reversi√≥n
    
    Fases:
    1. q0: Copia s√≠mbolos a ambas cintas, avanza ‚Üí
    2. q1: Retrocede en ambas cintas ‚Üê, borra cinta 0
    3. q2: Avanza borrando cinta 1
    4. qaccept: Acepta cuando termina
```

**Archivo:** `Inputs/MT/BinaryReverse_2Tapes_MT.txt`

**Tabla completa de transiciones (2 cintas):**

| Estado | S√≠mbolo (cinta 0) | Estado destino | Cinta 0: Escribe/Mueve | Cinta 1: Escribe/Mueve |
|--------|-------------------|----------------|------------------------|------------------------|
| q0     | 0                 | q0             | 0, R                   | 0, R                   |
| q0     | 1                 | q0             | 1, R                   | 1, R                   |
| q0     | .                 | q1             | ., L                   | ., L                   |
| q1     | 0                 | q1             | ., L                   | 0, L                   |
| q1     | 1                 | q1             | ., L                   | 1, L                   |
| q1     | .                 | q2             | ., R                   | ., R                   |
| q2     | 0                 | q2             | 0, R                   | ., R                   |
| q2     | 1                 | q2             | 1, R                   | ., R                   |
| q2     | .                 | qaccept        | ., S                   | ., S                   |

**Explicaci√≥n por fases:**

1. **Fase q0 (Copia a ambas cintas):**
   - `q0 --0--> q0`: Escribe '0' en ambas cintas, avanza ‚Üí‚Üí
   - `q0 --1--> q0`: Escribe '1' en ambas cintas, avanza ‚Üí‚Üí
   - `q0 --.--> q1`: Termina copia, retrocede ambas cintas

2. **Fase q1 (Retroceso y borrado cinta 0):**
   - `q1 --0--> q1`: Borra cinta 0 (.), mantiene '0' en cinta 1, retrocede ‚Üê‚Üê
   - `q1 --1--> q1`: Borra cinta 0 (.), mantiene '1' en cinta 1, retrocede ‚Üê‚Üê
   - `q1 --.--> q2`: Alcanza inicio, avanza para limpiar cinta 1

3. **Fase q2 (Limpiar cinta 1):**
   - `q2 --0--> q2`: Mantiene cinta 0, borra cinta 1, avanza ‚Üí‚Üí
   - `q2 --1--> q2`: Mantiene cinta 0, borra cinta 1, avanza ‚Üí‚Üí
   - `q2 --.--> qaccept`: Termina limpieza, ACEPTA

**Transiciones (formato multicinta):**
```
# Fase 1: Copiar a ambas cintas
q0 0 q0 0 R 0 R    # Copia '0' a cinta 0 y 1
q0 1 q0 1 R 1 R    # Copia '1' a cinta 0 y 1
q0 . q1 . L . L    # Fin copia, retrocede

# Fase 2: Borrar cinta 0, mantener cinta 1
q1 0 q1 . L 0 L    # Borra '0' en cinta 0
q1 1 q1 . L 1 L    # Borra '1' en cinta 0
q1 . q2 . R . R    # Vuelve al inicio

# Fase 3: Borrar cinta 1
q2 0 q2 0 R . R    # Mantiene cinta 0, borra cinta 1
q2 1 q2 1 R . R    # Mantiene cinta 0, borra cinta 1
q2 . qaccept . S . S # Termina ‚Üí ACEPTA
```

**Ejemplos:**
- ‚úÖ `0`, `1`, `10`, `101`, `1010` ‚Üí ACEPTADAS (todas)

**Nota:** Este ejemplo muestra el formato multicinta: `estado s√≠mbolo_le√≠do estado_dest escribe0 mov0 escribe1 mov1`

---

## üèóÔ∏è Arquitectura del C√≥digo

El proyecto sigue el principio de **Separaci√≥n de Responsabilidades (SRP)** con una arquitectura modular y limpia.

### Diagrama de Clases

```
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ    main     ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ            ‚îÇ            ‚îÇ
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ  Args   ‚îÇ  ‚îÇ  File   ‚îÇ ‚îÇ  Turing   ‚îÇ
         ‚îÇ         ‚îÇ  ‚îÇ Parser  ‚îÇ ‚îÇ  Machine  ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ            ‚îÇ
                      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
                      ‚îÇ Symbol  ‚îÇ       ‚îÇ
                      ‚îÇ State   ‚îÇ       ‚îÇ
                      ‚îÇAlphabet ‚îÇ       ‚îÇ
                      ‚îÇTransition‚îÇ      ‚îÇ
                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
                                        ‚îÇ
                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                         ‚îÇ                             ‚îÇ
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ   Turing    ‚îÇ          ‚îÇ     Turing       ‚îÇ
                    ‚îÇ   Machine   ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§     Machine      ‚îÇ
                    ‚îÇ    Model    ‚îÇ          ‚îÇ    Simulator     ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                    ‚îÇ
                                             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                             ‚îÇ    Trace     ‚îÇ
                                             ‚îÇ   Printer    ‚îÇ
                                             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

### Descripci√≥n Detallada de Clases

#### 1. **Args** (`arg_parser.h`, `arg_parser.cc`)

**Responsabilidad:** Parsear y almacenar argumentos de l√≠nea de comandos.

**Atributos privados:**
```cpp
std::string mtFile_;      // Ruta al fichero de definici√≥n de MT
std::string stringsFile_; // Ruta al fichero de cadenas
bool trace_;              // Flag para activar modo traza
```

**M√©todos p√∫blicos:**
```cpp
Args(int argc, char* argv[]);              // Constructor que parsea argumentos
const std::string& getMtFile() const;      // Obtiene fichero de MT
const std::string& getStringsFile() const; // Obtiene fichero de cadenas
bool getTrace() const;                     // Obtiene flag de traza
```

**Ejemplo de uso:**
```cpp
Args args(argc, argv);
std::string mtFile = args.getMtFile();
bool traceMode = args.getTrace();
```

---

#### 2. **Symbol** (`symbol.h`, `symbol.cc`)

**Responsabilidad:** Representar un s√≠mbolo del alfabeto.

**Atributos privados:**
```cpp
char symbol_; // Car√°cter que representa el s√≠mbolo
```

**M√©todos p√∫blicos:**
```cpp
Symbol(char c);                    // Constructor
char getSymbol() const;            // Obtiene el car√°cter
bool operator==(const Symbol& s);  // Comparaci√≥n
bool operator<(const Symbol& s);   // Ordenaci√≥n (para maps)
```

**Ejemplo de uso:**
```cpp
Symbol a('a');
Symbol blank('.');
if (a == blank) { /* ... */ }
```

---

#### 3. **State** (`state.h`, `state.cc`)

**Responsabilidad:** Representar un estado de la MT.

**Atributos privados:**
```cpp
std::string id_;     // Identificador del estado
bool isAccept_;      // ¬øEs estado de aceptaci√≥n?
```

**M√©todos p√∫blicos:**
```cpp
State(const std::string& id);      // Constructor
const std::string& getId() const;  // Obtiene ID
bool isAccept() const;             // ¬øEs aceptador?
void setAccept(bool accept);       // Marca como aceptador
```

**Ejemplo de uso:**
```cpp
State q0("q0");
State qaccept("qaccept");
qaccept.setAccept(true);
```

---

#### 4. **Alphabet** (`alphabet.h`, `alphabet.cc`)

**Responsabilidad:** Representar un alfabeto (conjunto de s√≠mbolos).

**Atributos privados:**
```cpp
std::vector<Symbol> symbols_; // Vector de s√≠mbolos
```

**M√©todos p√∫blicos:**
```cpp
Alphabet(const std::vector<Symbol>& symbols); // Constructor
bool contains(const Symbol& s) const;         // ¬øContiene s√≠mbolo?
```

---

#### 5. **Transition** (`transition.h`, `transition.cc`)

**Responsabilidad:** Representar una transici√≥n de la MT.

**Atributos privados:**
```cpp
State from_;                                           // Estado origen
State to_;                                             // Estado destino
Symbol readSymbol_;                                    // S√≠mbolo le√≠do (cinta 0)
std::map<int, std::pair<Symbol, Moves>> tapeActions_; // Acciones por cinta
```

**M√©todos p√∫blicos:**
```cpp
Transition(const State& from, const State& to, const Symbol& readSymbol,
           const std::map<int, std::pair<Symbol, Moves>>& tapeActions);
const State& getFrom() const;
const State& getTo() const;
const Symbol& getReadSymbol() const;
const std::map<int, std::pair<Symbol, Moves>>& getTapeActions() const;
```

**Estructura de datos:**
- `tapeActions_` es un `map<int, pair<Symbol, Moves>>`
- **Clave:** √çndice de cinta (0, 1, 2, ...)
- **Valor:** Par (s√≠mbolo a escribir, movimiento)

**Ejemplo de uso:**
```cpp
// Transici√≥n: q0 --a--> q1, escribe 'X' en cinta 0, mueve RIGHT
std::map<int, std::pair<Symbol, Moves>> actions;
actions[0] = std::make_pair(Symbol('X'), Moves::RIGHT);
Transition t(q0, q1, Symbol('a'), actions);
```

---

#### 6. **FileParser** (`file_parser.h`, `file_parser.cc`)

**Responsabilidad:** Parsear ficheros de definici√≥n de MT.

**M√©todos p√∫blicos:**
```cpp
TuringMachine parseFile(const std::string& filename);
```

**Proceso de parseo:**
1. Lee las 7 secciones del fichero
2. Construye objetos `State`, `Symbol`, `Alphabet`
3. Parsea transiciones l√≠nea por l√≠nea
4. Construye el map de acciones por cinta directamente
5. Retorna un objeto `TuringMachine`

**Ejemplo de c√≥digo interno:**
```cpp
// Parseo de transiciones
std::map<int, std::pair<Symbol, Moves>> tapeActions;
int tapeIndex = 0;
while (ss >> writeSymStr >> moveStr) {
  Symbol writeSymbol = Symbol(writeSymStr[0]);
  Moves move = (moveStr[0] == 'L') ? Moves::LEFT : 
               (moveStr[0] == 'R') ? Moves::RIGHT : Moves::STAY;
  tapeActions.insert(std::make_pair(tapeIndex, std::make_pair(writeSymbol, move)));
  tapeIndex++;
}
Transition t(from, to, readSymbol, tapeActions);
```

---

#### 7. **TuringMachine** (`turing_machine.h`, `turing_machine.cc`)

**Responsabilidad:** Facade que coordina Model y Simulator.

**Atributos privados:**
```cpp
TuringMachineModel model_;      // Datos de la MT
TuringMachineSimulator simulator_; // L√≥gica de ejecuci√≥n
```

**M√©todos p√∫blicos:**
```cpp
TuringMachine(std::vector<State> states, std::vector<Transition> transitions, 
              Alphabet stringAlphabet, Alphabet tapeAlphabet, 
              const std::string& initialStateId);
bool compute(String& input, bool trace, std::ostream& os) const;
const TuringMachineModel& getModel() const;
```

**Patr√≥n Facade:**
```cpp
// Constructor inicializa model_ y simulator_ con objetos directos (no punteros)
TuringMachine::TuringMachine(...)
  : model_(states, transitions, stringAlphabet, tapeAlphabet, initialStateId),
    simulator_(model_) {
}

// compute() delega al simulador
bool TuringMachine::compute(String& input, bool trace, std::ostream& os) const {
  return simulator_.compute(input, trace, os);
}
```

---

#### 8. **TuringMachineModel** (`turing_machine_model.h`, `turing_machine_model.cc`)

**Responsabilidad:** Almacenar la estructura de la MT (estados, transiciones, alfabetos).

**Atributos privados:**
```cpp
std::unordered_map<std::string, State> statesMap_;           // Estados por ID
std::map<std::string, std::vector<Transition>> transitionsMap_; // Transiciones por estado
Alphabet stringAlphabet_;                                    // Alfabeto de entrada
Alphabet tapeAlphabet_;                                      // Alfabeto de cinta
std::string initialStateId_;                                 // ID del estado inicial
```

**Optimizaciones:**
- ‚úÖ `unordered_map` para b√∫squeda O(1) de estados
- ‚úÖ `map` para transiciones ordenadas por estado origen
- ‚úÖ Getters devuelven `const&` para evitar copias

**M√©todos p√∫blicos:**
```cpp
const std::unordered_map<std::string, State>& getStates() const;
const std::map<std::string, std::vector<Transition>>& getTransitions() const;
const State& getInitialState() const; // Lanza excepci√≥n si no existe
const State& getStateById(const std::string& id) const;
```

**Ejemplo de uso:**
```cpp
const State& currentState = model.getStateById("q0");
const auto& transitions = model.getTransitions();
```

---

#### 9. **TuringMachineSimulator** (`turing_machine_simulator.h`, `turing_machine_simulator.cc`)

**Responsabilidad:** Ejecutar la simulaci√≥n de la MT.

**Atributos privados:**
```cpp
const TuringMachineModel& model_; // Referencia al modelo (no copia)
TracePrinter tracePrinter_;       // Impresora de trazas (composici√≥n)
```

**M√©todo principal:**
```cpp
bool compute(String& input, bool trace, std::ostream& os) const;
```

**Algoritmo de simulaci√≥n:**

```cpp
bool TuringMachineSimulator::compute(String& input, bool trace, std::ostream& os) const {
  // 1. Inicializar cintas
  std::map<int, Tape> tapes;
  tapes[0] = Tape(input);
  
  // 2. Estado inicial
  const State* currentState = &model_.getInitialState();
  
  // 3. Bucle principal
  int steps = 0;
  const int MAX_STEPS = 10000;
  
  while (steps < MAX_STEPS) {
    // a) Imprimir traza si est√° activa
    if (trace) {
      tracePrinter_.printStep(os, steps, *currentState, tapes, ...);
    }
    
    // b) ¬øEstado de aceptaci√≥n?
    if (currentState->isAccept()) {
      if (trace) tracePrinter_.printAcceptedMessage(os);
      return true;
    }
    
    // c) Leer s√≠mbolo de cinta 0
    Symbol readSymbol = tapes[0].read();
    
    // d) Buscar transici√≥n aplicable
    const Transition* applicableTransition = nullptr;
    for (const auto& t : model_.getTransitions().at(currentState->getId())) {
      if (t.getReadSymbol() == readSymbol) {
        applicableTransition = &t;
        break;
      }
    }
    
    // e) Si no hay transici√≥n, rechazar
    if (!applicableTransition) {
      if (trace) tracePrinter_.printRejectedMessage(os);
      return false;
    }
    
    // f) Aplicar transici√≥n
    for (const auto& [tapeIndex, action] : applicableTransition->getTapeActions()) {
      const Symbol& writeSymbol = action.first;
      const Moves& move = action.second;
      
      tapes[tapeIndex].write(writeSymbol);
      tapes[tapeIndex].move(move);
    }
    
    // g) Cambiar de estado
    currentState = &model_.getStateById(applicableTransition->getTo().getId());
    steps++;
  }
  
  // M√°ximo de pasos alcanzado
  if (trace) tracePrinter_.printMaxStepsMessage(os);
  return false;
}
```

---

#### 10. **TracePrinter** (`trace_printer.h`, `trace_printer.cc`)

**Responsabilidad:** Formatear y imprimir trazas de ejecuci√≥n (separaci√≥n de presentaci√≥n).

**M√©todos p√∫blicos:**
```cpp
void printHeader(std::ostream& os) const;
void printStep(std::ostream& os, int stepNumber, const State& currentState,
               const std::map<int, Tape>& tapes, const Transition& transition) const;
void printAcceptedMessage(std::ostream& os) const;
void printRejectedMessage(std::ostream& os) const;
void printMaxStepsMessage(std::ostream& os) const;
```

**Salida formateada:**
```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  PASO 0                                       ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  Estado actual: q0                            ‚ïë
‚ïë  S√≠mbolos le√≠dos: cinta0=[a], cinta1=[.]      ‚ïë
‚ïë  Transici√≥n: q0 ‚Üí q1                          ‚ïë
‚ïë  Acciones:    cinta0: escribir 'X', mover ‚Üí   ‚ïë
‚ïë               cinta1: escribir '.', mover ‚Üí   ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  Estado de las cintas:    cinta0: [X]         ‚ïë
‚ïë                           cinta1: [.]         ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
```

**Patr√≥n de composici√≥n:**
```cpp
class TuringMachineSimulator {
  TracePrinter tracePrinter_; // Composici√≥n (no herencia)
  
  void compute(...) {
    if (trace) {
      tracePrinter_.printStep(os, ...); // Delega la impresi√≥n
    }
  }
};
```

---

#### 11. **String** y **Tape**

**String** (`string.h`, `string.cc`): Representa una cadena como vector de s√≠mbolos.

**Tape**: Representa una cinta de la MT con:
- Vector de s√≠mbolos
- Posici√≥n del cabezal
- Operaciones: `read()`, `write()`, `move()`

---

## üîß Compilaci√≥n y Ejecuci√≥n

### Compilar

```bash
cd pract-2
make
```

El `Makefile` detecta autom√°ticamente todos los ficheros `.cc` en `src/` y genera el ejecutable `pract-02`.

### Limpiar

```bash
make clean
```

### Ejecutar

**Sintaxis:**
```bash
./pract-02 <fichero_MT> <fichero_cadenas> [--trace]
```

**Par√°metros:**
- `<fichero_MT>`: Ruta al fichero de definici√≥n de la MT
- `<fichero_cadenas>`: Ruta al fichero con cadenas de entrada
- `[--trace]`: (Opcional) Activa el modo traza detallado

**Salida:**
- Resultados se guardan en `FileOut.txt`
- Si `--trace` est√° activo, la traza se imprime en consola

---

## üìù Ejemplos de Uso

### Ejemplo 1: MT simple sin traza

```bash
./pract-02 Inputs/MT/EvenAs_1Tape_MT.txt Inputs/Strigs/strings_evenas.txt
```

**Salida en `FileOut.txt`:**
```
aa: ACEPTADA -> Resultado: aa.
aaaa: ACEPTADA -> Resultado: aaaa.
a: RECHAZADA -> Resultado: a.
aaa: RECHAZADA -> Resultado: aaa.
```

### Ejemplo 2: MT con traza

```bash
./pract-02 Inputs/MT/BinaryReverse_2Tapes_MT.txt Inputs/Strigs/strings_binary.txt --trace
```

**Salida en consola:**
```
========================================================
PROCESANDO CADENA: "101"
========================================================

TRAZA DE EJECUCI√ìN
========================================================

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  PASO 0                                           ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  Estado actual: q0                                ‚ïë
‚ïë  S√≠mbolos le√≠dos: cinta0=[1], cinta1=[.]          ‚ïë
‚ïë  Transici√≥n: q0 ‚Üí q0                              ‚ïë
‚ïë  Acciones:    cinta0: escribir '1', mover ‚Üí(der)  ‚ïë
‚ïë               cinta1: escribir '1', mover ‚Üí(der)  ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  Estado de las cintas:    cinta0: [1] 0 1         ‚ïë
‚ïë                           cinta1: [.] . .         ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

[... m√°s pasos ...]

RESULTADO FINAL: 101 -> ‚úì ACEPTADA
Cinta resultante: ...
```

### Ejemplo 3: Script de prueba autom√°tica

```bash
./test_all.sh
```

Ejecuta todas las MTs de ejemplo y muestra los resultados.

---

## üé® Caracter√≠sticas de Dise√±o

### 1. **Sin Punteros, Solo Referencias**

Todo el c√≥digo usa referencias (`&`) en lugar de punteros (`*`):

```cpp
// ‚úÖ Bueno: Referencias
const State& getStateById(const std::string& id) const {
  auto it = statesMap_.find(id);
  if (it == statesMap_.end()) {
    throw std::runtime_error("Estado no encontrado: " + id);
  }
  return it->second;
}

// ‚ùå Malo: Punteros (versi√≥n antigua)
const State* getStateById(const std::string& id) const {
  auto it = statesMap_.find(id);
  if (it == statesMap_.end()) {
    return nullptr; // Requiere verificaci√≥n en cada uso
  }
  return &it->second;
}
```

### 2. **Composici√≥n sobre Herencia**

El `TuringMachineSimulator` **contiene** un `TracePrinter` (composici√≥n) en lugar de heredar de √©l:

```cpp
class TuringMachineSimulator {
  TracePrinter tracePrinter_; // Composici√≥n: "tiene-un" TracePrinter
};
```

### 3. **Objetos Directos en lugar de unique_ptr**

```cpp
class TuringMachine {
  TuringMachineModel model_;      // ‚úÖ Objeto directo
  TuringMachineSimulator simulator_; // ‚úÖ Objeto directo
  
  // ‚ùå Versi√≥n antigua:
  // std::unique_ptr<TuringMachineModel> model_;
  // std::unique_ptr<TuringMachineSimulator> simulator_;
};
```

### 4. **Encapsulaci√≥n con Getters**

```cpp
class Args {
private:
  std::string mtFile_;
  std::string stringsFile_;
  bool trace_;
  
public:
  const std::string& getMtFile() const { return mtFile_; }
  const std::string& getStringsFile() const { return stringsFile_; }
  bool getTrace() const { return trace_; }
};
```

### 5. **Separaci√≥n de Responsabilidades**

- **Model**: Solo datos
- **Simulator**: Solo l√≥gica de ejecuci√≥n
- **TracePrinter**: Solo presentaci√≥n
- **FileParser**: Solo parseo

---

## üìÑ Licencia

Este proyecto es material acad√©mico para la asignatura de Complejidad Computacional.

---

**√öltima actualizaci√≥n:** 20 Octubre 2025
